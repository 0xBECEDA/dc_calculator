#+STARTUP: showall indent hidestars

~Разбор выражения~
dc -e
"[32P1-d0!=b]sb[42P1-d0!=s]ss[lilbxln+li-2*1-lsx]sr[li1-silrx10Pli1!=m]sm
10 1+snlnsilmx"

При вводе в косоль данное выражение создает "елочку" из звездочек. Цель
данной работы разобрать, как работает компнда dc и "перевернуть" елочку.

~dc~ представляет собой по факту настольный калькулятор, который
поддерживает также постфиксную нотацию. Ключ ~-e~ означает, что дальше
идет скрипт.

Особенность ~dc~ состоит в том, что внутри него можно объявлять и
использовать макросы.

Обычно внутри квадратных скобок заключается строка, которую нужно
отправить в стек.

Но в данном случае внутри квадратных скобок у нас макросы. А команда
s+имя регистра отправляет результат макрорасрытия в указанный регистр. dc
поддерживает до 256 регистров.

Таким образом макрос ~32P1-d0!=b~ отправляется в регистр ~b~, макрос
~42P1-d0!=s~ - в регистр ~s~,  ~lilbxln+li-2*1-lsx~ - в регистр ~r~,
а ~li1-silrx10Pli1!=m~ - в регистр ~m~.

Далее следует цифра 10. А в нашей "елочке" 10 рядов. Если изменять этот
параметр, то количество рядов уменьшается/увеличивается в зависимости от
параметра.
Кладем в стек 10.

Далее следует ~1+snlnsilmx~.
Не очень понятно, как его разбирать, но ясно, что данная команда должна
привести в действие все остальные.
Поэтому начнем с того, что именно заставляет работать данное выражени.


~Разбираем макрос lilbxln+li-2*1-lsx~
Начинаем с конца, поскольку его наиболее просто разбрать с моей т з.
Переписываем с пробелами, чтоб было проще воспринимать написанное.

~li~ ~lb~ ~x~ ~ln~ ~+~ ~li~ ~-~ ~2~ ~*~ ~1~ ~-~ ~ls~ ~x~

Судя по разбору получается, что данные макрос выполняет сразу несколько
функций:
- инициирует вычисление макроса ~32P1-d0!=b~
- инициирует вычисление макроса ~42P1-d0!=s~
- вычисляет, сколько звездочек и пробелов должно быть напечатано в
  текущем (?) ряду

~li~ - запушить в стек содержимое регистра ~i~
~lb~ - запушить в стек содержимое регистра ~b~ (а там у нас лежит макрос ~32P1-d0!=b~)
~x~ - исполнить последовательность символов на вершине стека как команды
dc. Т.е. вычислить ~32P1-d0!=b~.
~ln~ - запушить в стек содержимое регистра ~n~.
~+~ - сложить два значения наверху стека. Т.е. в нашем случае это скорее
всего результат от вычисления ~32P1-d0!=b~ и содержимое ~n~. То есть
теперь мы знаем, что результат от вычисления ~32P1-d0!=b~ и содержимое
~n~ - это числа
~li~ - запушить в стек содержимое регистра ~i~
~-~ - вычесть два вырежения на вершине стека. Причем самое верхнее
вычитается из следующего. В нашем случае из результата сложения будет
вычтено содержимое регистра ~i~ (итак мы узнали, что в ~i~ должно попасть
какое-то число).
~2~ - в стек положили 2
~*~ - умножаем два значения на вершине стека. В нашем случае это
результат от вычитания и 2.
~1~ - в стек полоили 1
~-~ - вычитаем два выражения. Т.е. из результата умножения вычитаем 1.
~ls~ - отправляем в стек содержимое регистра ~s~
~x~ - исполнить последовательность символов на вершине стека как команды
dc. Т.е. вычислить ~42P1-d0!=s~, поскольку именно этот макрос лежал в
регистре ~s~.

~Разбираем макрос 32P1-d0!=b~

Переписываем с пробелами:
~32P~ ~1~ ~-~ ~d~ ~0~  ~!=b~
~32P~ - печать пробела. 32 - это аски-код пробела. P забирает со стека
число 32 и интерпретирует его как аски-код.
~1~ - кладем в стек 1
~-~ вычитаем два выражения. В нашем случае единица вычитается из того,
что лежит на стеке сразу за ней.
~d~ - значение на вершине стека удваивается
~0~ - на стек положили 0
 ~!=b~ - берем со стека два выражения, и вызываем макрос в ~b~, если они
не равны. В нашем случае получается, что макрос ~32P1-d0!=b~ вызывает сам
себя - ведь это он лежит в регистре ~b~, если результат вычитания != 0.

~Разбираем макрос 42P1-d0!=s~

~32P~ ~1~ ~-~ ~d~ ~0~  ~!=s~

~42P~ печатает звездочку. 42 - это аски-код звуздочки. P забирает со стека
число 42 и интерпретирует его как аски-код.
Дальше все аналогично макросу ~32P1-d0!=b~.

~Разбираем макрос li1-silrx10Pli1!=m~

Как обычно переписываем с пробелами:
~li~ ~1~ ~-~ ~si~ ~lr~ ~x~ ~10~ ~P~ ~li~ ~1~ ~!=m~

~li~ - запушить в стек содержимое регистра ~i~ - число 11.
~1~ - кладем в стек 1
~-~ вычитаем два выражения. В нашем случае единица вычитается из того,
что лежит на стеке сразу за ней.
~si~ - забрать результат вычисления в регистр ~i~ - число 10.
~lr~ - запушить в стек содержимое регистра ~r~ - макрос ~lilbxln+li-2*1-lsx~
~x~ - выполнить содержимое вершины стека как последовательность команд
dc. То есть запустить ~lilbxln+li-2*1-lsx~.
~10~ - пушим 10 в стек. В данном случае это аски-код перевода строки,
который напечатает ~P~.
~li~ - отпраялем содержимое ~i~ в стек. Это число 10 на данный момент.
~1~ - кладем в стек 1
~!=m~ - снять со стека 2 числа и если они не равны, запустить макрос,
лежищий в ~m~, то есть запустить этот же макрос

Если суммировать все вышесказанное по данному макросу, то получается, что
этот макрос - это цикл, который будет запускать весь остальной процесс по
печати рядов звездочек.
Регистр ~i~ - это регистр-счетчик, в котором будет лежать уменьшающееся
число. Цикл кончится тогда, когда содержимое ~i~ станет  = 1.


Теперь возвращаемся к разбору ~1+snlnsilmx~
Переписываем с пробелами:
~1~ ~+~ ~sn~ ~ln~ ~si~ ~lm~ ~x~

~1~ - положить 1 в стек
~+~ - взять со стека 2 значения и сложить их. У нас там лежит 10 и 1.
~sn~ - взять число ~11~  со стека и пожить в регистр ~n~
~ln~ - положить содержимое ~n~ в стек
~si~ - положить значение на вершине стека в ~i~
~lm~ - положить содержимое ~m~ на стек
~x~ - исполнить символы на вершине стека как последовательность команд
dc. То есть вычислить ~li1-silrx10Pli1!=m~.

Можно задаться вопросом, зачем брать результат сложения - число 11 - и
сначала класть его в регистр ~n~, затем снова класть в стек и снимать в
регистр ~i~, неужели нельзя сразу положить в ~i~? Нет, поскольку мы
хотим, чтоб число оказалась и в ~n~ и в ~i~, видимо, в dc отсутствует
аналог ассемблерного ~mov~, поэтому компировать значение в регистр можно
только через стек.

Итак, суммируем разбор.
~32P1-d0!=b~ - отвечает за печать пробела
~42P1-d0!=s~ - отвечает за печать звездочки
~lilbxln+li-2*1-lsx~ - должен вычислить, сколько звездочек надо
напечатать, и вызвать макросы, которые напечатают звездочку и пробел после
нее.
~li1-silrx10Pli1!=m~ - запустить цикл по печати рядов звездочек
~1+snlnsilmx~ - установить счетчик цикла и запустить цикл, который будет
запускать всю остальную программу
